1)
#include<stdio.h>
#include <stdlib.h>
#include <string.h>

struct CalendarDay {
 char* dayName;
 int date;
 char* activity;
};

void create(struct CalendarDay calendar[7]) {
 for (int i = 0; i < 7; i++) {
 calendar[i].dayName = (char*)malloc(20); // Allocate memory for day name
 calendar[i].activity = (char*)malloc(100); // Allocate memory for activity description
 }
}

void read(struct CalendarDay calendar[7]) {
 for (int i = 0; i < 7; i++) {
 printf("Enter day name for Day %d: ", i + 1);
 scanf("%s", calendar[i].dayName);
 printf("Enter date for Day %d: ", i + 1);
 scanf("%d", &calendar[i].date);
 printf("Enter activity for Day %d: ", i + 1);
 scanf(" %[^\n]", calendar[i].activity); 


 }
}

void display(struct CalendarDay calendar[7]) {
 printf("\nActivity Details for the Week:\n");
 for (int i = 0; i < 7; i++) {
 printf("Day Name: %s\n", calendar[i].dayName);
 printf("Date: %d\n", calendar[i].date);
 printf("Activity: %s\n\n", calendar[i].activity);
 }
}
int main() {
 struct CalendarDay calendar[7];
 create(calendar);
 read(calendar);
 display(calendar);
 
 for (int i = 0; i < 7; i++) {
 free(calendar[i].dayName);
 free(calendar[i].activity);
 }
 return 0;
}
------------------------------------------------------------------------
2)#include<stdio.h>
#include<stdlib.h>
#include<string.h>

char str[100], pat[50], rep[50], ans[100];
int i, j, c, m, k, flag = 0;

void stringmatch() {
    i = m = c = j = 0;
    while (str[c] != '\0') {
        if (str[m] == pat[i]) {
            i++, m++;
            if (pat[i] == '\0') {
                flag = 1;
                for (k = 0; rep[k] != '\0'; k++, j++)
                    ans[j] = rep[k];
                i = 0;
                c = m;
            }
        }
        else {
            ans[j] = str[c];
            j++;
            c++;
            m = c;
            i = 0;
        }
    }
    ans[j] = '\0'; // Null terminate the resultant string
}

int main() {
    printf("\nEnter main string: ");
    gets(str); // Note: gets() is deprecated, consider using fgets() instead
    printf("\nEnter pattern string: ");
    gets(pat);
    printf("Enter replace string: ");
    gets(rep);
    stringmatch();
    if (flag == 1)
        printf("\nThe resultant string: %s", ans);
    else
        printf("\nPattern not found.");
    return 0;
}
-----------------------------------------------------------------------------------
3)
#include <stdio.h>

#define MAX_SIZE 5

int top = -1;
int stack[MAX_SIZE];

void push(int item) {
    if (top == MAX_SIZE - 1) {
        printf("Overflow\n");
    } else {
        stack[++top] = item;
    }
}

int pop() {
    int num;
    if (top == -1) {
        printf("Underflow\n");
        return -1; // return an error value
    } else {
        num = stack[top--];
        return num;
    }
}

int isPalindrome() {
    if (top == -1) {
        printf("Stack is empty\n");
        return -1; // return an error value
    }
    int i;
    for (i = 0; i <= top / 2; i++) {
        if (stack[i] != stack[top - i]) {
            return 0; // Not palindrome
        }
    }
    return 1; // Palindrome
}

void display() {
    if (top == -1) {
        printf("Stack is empty\n");
    } else {
        printf("Stack content:\n");
        for (int i = top; i >= 0; i--) {
            printf("%d\n", stack[i]);
        }
    }
}

int main() {
    int choice, item;

    do {
        printf("\nMain Menu\n");
        printf("1. Push\n");
        printf("2. Pop\n");
        printf("3. Check Palindrome\n");
        printf("4. Display\n");
        printf("5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter an element to push: ");
                scanf("%d", &item);
                push(item);
                break;
            case 2:
                item = pop();
                if (item != -1) {
                    printf("Popped item: %d\n", item);
                }
                break;
            case 3:
                if (isPalindrome() == 1) {
                    printf("Stack content is palindrome\n");
                } else if (isPalindrome() == 0) {
                    printf("Stack content is not palindrome\n");
                }
                break;
            case 4:
                display();
                break;
            case 5:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice\n");
        }
    } while (choice != 5);

    return 0;
}

-------------------------------------------------------------------------------------
4)#include<stdio.h>

void push(char);
char pop();
void eval();
int prec(char);

char infix[30], postfix[30], stack[30];
int top = -1;

int main() {
    printf("Enter a valid infix expression: ");
    scanf("%s", infix);
    eval();
    printf("Postfix expression is %s\n", postfix);
    return 0;
}

void eval() {
    int i = 0, j = 0;
    char symb, temp;
   

    for (i = 0; infix[i] != '\0'; i++) {
        symb = infix[i];
        switch (symb) {
            case '(':
                push(symb);
                break;
            case ')':
                temp = pop();
                while (temp != '(') {
                    postfix[j] = temp;
                    j++;
                    temp = pop();
                }
                break;
            case '+':
            case '-':
            case '*':
            case '/':
            case '%':
            case '^':
                while (prec(stack[top]) >= prec(symb)) {
                    temp = pop();
                    postfix[j] = temp;
                    j++;
                }
                push(symb);
                break;
            default:
                postfix[j] = symb;
                j++;
        }
    }

    while (top > -1) {
        temp = pop();
        postfix[j] = temp;
        j++;
    }
    postfix[j] = '\0';
}

void push(char item) {
    top++;
    stack[top] = item;
}

char pop() {
    char item;
    if (top == -1) {
        printf("Stack Underflow\n");
        return -1;
    } else {
        item = stack[top];
        top--;
        return item;
    }
}

int prec(char symbol) {
    switch (symbol) {
        case '^':
            return 3;
        case '*':
        case '/':
        case '%':
            return 2;
        case '+':
        case '-':
            return 1;
        default:
            return 0;
    }
}
------------------------------------------------------------------------------------
5 a)
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

void push(int[], int *, int);
int pop(int[], int *);

int main() {
    int iastack[50], i, op1, op2, res;
    char expr[50], symb;
    int top = -1;

    printf("\nEnter a valid postfix expression: ");
    scanf("%s", expr);

    for (i = 0; i < strlen(expr); i++) {
        symb = expr[i];
        if (isdigit(symb)) {
            push(iastack, &top, symb - '0');
        } else {
            op2 = pop(iastack, &top);
            op1 = pop(iastack, &top);
            switch (symb) {
                case '+':
                    res = op1 + op2;
                    break;
                case '-':
                    res = op1 - op2;
                    break;
                case '*':
                    res = op1 * op2;
                    break;
                case '/':
                    if (op2 != 0)
                        res = op1 / op2;
                    else {
                        printf("Error: Division by zero\n");
                        exit(1);
                    }
                    break;
                case '%':
                    if (op2 != 0)
                        res = op1 % op2;
                    else {
                        printf("Error: Modulo by zero\n");
                        exit(1);
                    }
                    break;
                case '^':
                    res = (int)pow(op1, op2);
                    break;
            }
            push(iastack, &top, res);
        }
    }
    res = pop(iastack, &top);
    printf("\nValue of %s expression is %d\n", expr, res);
    return 0;
}

void push(int Stack[], int *t, int elem) {
    *t = *t + 1;
    Stack[*t] = elem;
}

int pop(int Stack[], int *t) {
    int elem;
    elem = Stack[*t];
    *t = *t - 1;
    return elem;
}
-----------------------------------------------------------------------------------
5 b)#include <stdio.h>

void towers(int, char, char, char);

int main() {
    int num;
    printf("Enter the number of disks: ");
    scanf("%d", &num);
    printf("The sequence of moves involved in the Tower of Hanoi are:\n");
    towers(num, 'A', 'C', 'B');
    printf("\n");
    return 0;
}

void towers(int num, char frompeg, char topeg, char auxpeg) {
    if (num == 1) {
        printf("\nMove disk 1 from peg %c to peg %c", frompeg, topeg);
        return;
    }
    towers(num - 1, frompeg, auxpeg, topeg);
    printf("\nMove disk %d from peg %c to peg %c", num, frompeg, topeg);
    towers(num - 1, auxpeg, topeg, frompeg);
}
-------------------------------------------------------------------------------------
6.#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define SIZE 5

void insert(char [], int *, int *, char);
char del(char [], int *, int *);
void display(char [], int, int);
bool qfull(int, int);
bool qempty(int, int);

int main() {
    char q[SIZE];
    int front = -1, rear = -1;
    int choice;
    char elem;

    for (;;) {
        printf("\nQueue Operations\n");
        printf("=====================");
        printf("\n1. Qinsert\n2. Qdelete\n3. Qdisplay\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        getchar(); // Consume newline character

        switch (choice) {
            case 1:
                if (!qfull(front, rear)) {
                    printf("\nEnter an element: ");
                    scanf("%c", &elem);
                    insert(q, &front, &rear, elem);
                } else {
                    printf("\nQueue is Full\n");
                }
                break;

            case 2:
                if (!qempty(front, rear)) {
                    elem = del(q, &front, &rear);
                    printf("\nDeleted element is %c\n", elem);
                } else {
                    printf("\nQueue is Empty\n");
                }
                break;

            case 3:
                if (!qempty(front, rear)) {
                    printf("\nContents of the Queue are:\n");
                    display(q, front, rear);
                } else {
                    printf("\nQueue is Empty\n");
                }
                break;

            case 4:
                exit(0);

            default:
                printf("\nInvalid choice\n");
                break;
        }
    }

    return 0;
}

bool qfull(int front, int rear) {
    if ((rear + 1) % SIZE == front)
        return true;
    else
        return false;
}

bool qempty(int front, int rear) {
    if (front == -1)
        return true;
    else
        return false;
}

void insert(char queue[], int *front, int *rear, char val) {
    if (*rear == -1) {
        *front = *rear = 0;
    } else {
        *rear = (*rear + 1) % SIZE;
    }
    queue[*rear] = val;
}

char del(char queue[], int *front, int *rear) {
    char el = queue[*front];
    if (*front == *rear) {
        *front = *rear = -1;
    } else {
        *front = (*front + 1) % SIZE;
    }
    return el;
}

void display(char queue[], int front, int rear) {
    int i;
    if (front <= rear) {
        for (i = front; i <= rear; i++) {
            printf("%c\t", queue[i]);
        }
    } else {
        printf("\n");
        for (i = front; i < SIZE; i++) {
            printf("%c\t", queue[i]);
        }
        for (i = 0; i <= rear; i++) {
            printf("%c\t", queue[i]);
        }
        printf("\n");
    }
}
-------------------------------------------------------------------------------------------------
7.#include<stdio.h>
#include<stdlib.h>
#include<string.h>

struct node {
    char usn[11], name[40], prog[4];
    int sem;
    char ph[11];
    struct node *link;
};

typedef struct node* PTR;

PTR get(void);
void freeN(PTR);
PTR insrear(PTR);
PTR delfront(PTR);
PTR insfront(PTR);
PTR delrear(PTR);
void disp(PTR);

int main() {
    PTR first = NULL;
    int ch, num, i;
    
    printf("\nEnter the number of Students N: ");
    scanf("%d", &num);

    for (i = 0; i < num; i++) {
        printf("Enter Data for Node %d: ", i + 1);
        first = insfront(first);
    }

    for (;;) {
        printf("\nQUEUE OPERATIONS");
        printf("====================");
        printf("\n1. Insert Front\n2. Insert Rear\n3. Delete Front\n4. Delete Rear\n5. Display\n6. Exit\n");
        printf("\nEnter your choice: ");
        scanf("%d", &ch);
        switch (ch) {
            case 1:
                first = insfront(first);
                break;
            case 2:
                first = insrear(first);
                break;
            case 3:
                first = delfront(first);
                break;
            case 4:
                first = delrear(first);
                break;
            case 5:
                disp(first);
                break;
            case 6:
                exit(0);
        }
    }
    return 0;
}

PTR get() {
    PTR newborn;
    newborn = (PTR)malloc(sizeof(struct node));
    if (newborn == NULL) {
        printf("\nMemory Overflow");
        exit(0);
    }
    printf("\nEnter USN: ");
    scanf("%s", newborn->usn);
    printf("Enter name: ");
    scanf("%s", newborn->name);
    printf("Enter Program name: ");
    scanf("%s", newborn->prog);
    printf("Enter semester: ");
    scanf("%d", &newborn->sem);
    printf("Enter Phone no: ");
    scanf("%s", newborn->ph);
    return newborn;
}

void freeN(PTR x) {
    free(x);
}

PTR insrear(PTR first) {
    PTR temp, cur;
    temp = get();
    temp->link = NULL;
    if (first == NULL)
        return temp;
    cur = first;
    while (cur->link != NULL) {
        cur = cur->link;
    }
    cur->link = temp;
    return first;
}

PTR delfront(PTR first) {
    PTR temp;
    if (first == NULL) {
        printf("\nSLL is empty cannot delete");
        return first;
    }
    temp = first;
    first = first->link;
    printf("\nNode deleted is %s : ", temp->name);
    freeN(temp);
    return first;
}

void disp(PTR first) {
    PTR curr;
    int count = 0;
    if (first == NULL) {
        printf("\nSLL is empty ");
        return;
    }
    printf("\nThe contents of SLL are : ");
    curr = first;
    printf("\nUSN\t\tName\tProgram\tSem\tPhone num");
    while (curr != NULL) {
        printf("\n%10s\t%s\t%s\t%d\t%s", curr->usn, curr->name, curr->prog, curr->sem, curr->ph);
        curr = curr->link;
        count++;
    }
    printf("\n\nSLL has %d nodes", count);
}

PTR insfront(PTR first) {
    PTR temp;
    temp = get();
    temp->link = first;
    return temp;
}

PTR delrear(PTR first) {
    PTR cur, prev;
    if (first == NULL) {
        printf("\nSLL is empty cannot delete");
        return first;
    }
    prev = NULL;
    cur = first;
    if (cur->link == NULL) {
        printf("\nNode deleted for %s : ", cur->name);
        freeN(cur);
        return NULL;
    }
    while (cur->link != NULL) {
        prev = cur;
        cur = cur->link;
    }
    prev->link = cur->link;
    printf("\nNode deleted for %s : ", cur->name);
    freeN(cur);
    return first;
}
---------------------------------------------------------------------------------------------------
9)
show array representation of two polynomial write a c function to add two polynomial A(x) and B(x) A(x)=2x^10+x+3, B(x)=x^5+10x^3+3x^2+12

#include<stdio.h>

#define size 11

void add(int pA[],int pB[],int pC[]){
    for (int i = 0; i < size; i++)
    {
        pC[i]=pA[i]+pB[i];
        /* code */
    }
    
}

void pri(int p[]){
    for (int i=size-1; i>=0; i--)
    {
        //printf("polynomial");
        if (p[i]!=0)
        {
            if (i!=0)
            {
                printf("%dx^%d+",p[i],i);
                /* code */
            }
            else{
                printf("%d",p[i]);
            }
            
            /* code */
        }
        
        /* code */
    }
    printf("\n");
}
int main(){
    int pA[size]={3,1,0,0,0,0,0,0,0,0,2};
    int  pB[size]={12,0,3,10,0,1};
    int pC[size]={0};
    add(pA,pB,pC);
    pri(pA);
    printf("\n");
    pri(pB);
    pri(pC);
    return 0;
}
--------------------------------------------------------------------------------------------------------
8)

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
struct node
{
int usn;
char name[30], dept[4], desig[30], ph[11];
 int sal;
struct node *plink;
struct node *nlink;
};
typedef struct node* NODE;
NODE getn(void);
void freen(NODE);
NODE insrear(NODE);
NODE delfront(NODE);
NODE insfront(NODE);
NODE delrear(NODE);
void disp(NODE);
int main()
{
NODE first = NULL;
int ch, num, i;
 printf("\nEnter the number of Employees N : "); scanf("%d", &num);
for(i=0;i<num;i++)
{
printf("\nEnter Data for Node %d :\n", i+1);
first = insrear(first);
}
for(;;)
{
printf("\nDLL OPERATIONS\n");
printf("====================");

printf("\n1.Insert Rear\n2.Delete Front\n3.Insert Front\n4.Delete Rear\n5.Display\n6.Exit\n");
printf("\nEnter your choice\n");
scanf("%d",&ch);
switch(ch)
{
case 1: first = insrear(first);
break;
case 2: first = delfront(first);
break;
case 3: first = insfront(first);
break;
case 4: first = delrear(first);
break;
case 5: disp(first);
break;
case 6: exit(0);
}
}
 return 0;
}
NODE getn()
{
NODE newborn;
newborn = (NODE)malloc(sizeof(struct node));
if(newborn == NULL)
{
printf("\nMemory Overflow");
exit(0);
}
printf("\nEnter SSN : ");
 scanf("%d",&newborn->usn);
 printf("\nEnter name : ");
scanf("%s",newborn->name);
 printf("\nEnter Department : ");
 scanf("%s", newborn->dept);
 printf("\nEnter Designation : ");
 scanf("%s", newborn->desig);
printf("\nEnter Salary : ");
 scanf("%d",&newborn->sal);
printf("\nEnter Phone no : ");
 scanf("%s",newborn->ph);
return newborn;
}

void freen(NODE x)
{
free(x);
}
NODE insrear(NODE first)
{
NODE temp,cur;
temp = getn();
temp->plink = temp->nlink = NULL;
 if(first == NULL)
 return temp;
 cur = first;
 while(cur->nlink != NULL)
 {
 cur = cur->nlink;
 }
 cur->nlink = temp;
 temp->plink = cur;
 return first;
}
NODE insfront(NODE first)
{
 NODE temp;
temp = getn();
 temp->plink = temp->nlink = NULL;
 temp->nlink = first;
 first = temp;
 return first;
}
NODE delrear(NODE first)
{
NODE cur, prev;
if(first == NULL)
{
printf("\nDLL is empty\n");
return first;
}

cur = first;
if(cur->nlink == NULL)
{
 printf("\nNode deleted for %s\n",cur->name);
 freen(cur);
 return NULL;
}
 while(cur->nlink != NULL)
 {
 cur = cur->nlink;
 }
 prev = cur->plink;
 prev->nlink = NULL;
printf("\nNode deleted for %s\n",cur->name);
freen(cur);
return first;
}
NODE delfront(NODE first)
{
NODE temp;
if(first == NULL)
{
printf("\nDLL is empty\n");
return first;
}
if(first->nlink == NULL)
{
printf("\nNode deleted for %s\n",first->name);
freen(first);
return NULL;
}
temp = first;
first = first->nlink;
first->plink = NULL;
printf("\nNode deleted for %s\n",temp->name);
freen(temp);
return first;
}

void disp(NODE first)
{
NODE curr;
int count = 0;
if(first == NULL)
{
printf("\nDLL is empty\n");
return;
}
printf("\nThe contents of DLL are :\n");
curr = first;
 printf("\nSSN\tName\tDept\tDesignation\tSalary\t\tPhone No");
while(curr != NULL)
{
printf("\n%-5d\t%s\t%s\t%s\t\t%-7d\t\t%-11s",curr->usn, curr->name, curr->dept, curr->desig, 
curr->sal, curr->ph);
curr = curr->nlink;
count++;
}
printf("\n\nDLL has %d nodes\n", count);
}
----------------------------------------------------------------------------------------
10)
#include <stdio.h>
#include <stdlib.h>

// Structure of a BST node
struct Node {
    int data;
    struct Node *left;
    struct Node *right;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a node into BST
struct Node* insert(struct Node* root, int data) {
    if (root == NULL)
        return createNode(data);
    
    if (data < root->data)
        root->left = insert(root->left, data);
    else if (data > root->data)
        root->right = insert(root->right, data);
    
    return root;
}

// Function to traverse the BST in inorder
void inorderTraversal(struct Node* root) {
    if (root != NULL) {
        inorderTraversal(root->left);
        printf("%d ", root->data);
        inorderTraversal(root->right);
    }
}

// Function to traverse the BST in preorder
void preorderTraversal(struct Node* root) {
    if (root != NULL) {
        printf("%d ", root->data);
        preorderTraversal(root->left);
        preorderTraversal(root->right);
    }
}

// Function to traverse the BST in postorder
void postorderTraversal(struct Node* root) {
    if (root != NULL) {
        postorderTraversal(root->left);
        postorderTraversal(root->right);
        printf("%d ", root->data);
    }
}

// Function to search for a key in the BST
void search(struct Node* root, int key) {
    if (root == NULL) {
        printf("Element %d not found in BST.\n", key);
        return;
    }

    if (root->data == key) {
        printf("Element %d found in BST.\n", key);
        return;
    }

    if (key < root->data)
        search(root->left, key);
    else
        search(root->right, key);
}

int main() {
    struct Node* root = NULL;
    int choice, key;

    // Creating the initial BST
    int arr[] = {6, 9, 5, 2, 8, 15, 24, 14, 7, 8, 5, 2};
    int n = sizeof(arr) / sizeof(arr[0]);
    for (int i = 0; i < n; i++)
        root = insert(root, arr[i]);

    do {
        printf("\n----- MENU -----\n");
        printf("1. Traverse BST (Inorder)\n");
        printf("2. Traverse BST (Preorder)\n");
        printf("3. Traverse BST (Postorder)\n");
        printf("4. Search Element in BST\n");
        printf("5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Inorder Traversal: ");
                inorderTraversal(root);
                printf("\n");
                break;
            case 2:
                printf("Preorder Traversal: ");
                preorderTraversal(root);
                printf("\n");
                break;
            case 3:
                printf("Postorder Traversal: ");
                postorderTraversal(root);
                printf("\n");
                break;
            case 4:
                printf("Enter element to search: ");
                scanf("%d", &key);
                search(root, key);
                break;
            case 5:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice! Please enter a valid choice.\n");
        }
    } while (choice != 5);

    return 0;
}
---------------------------------------------------------------------
11)
#include <stdio.h>
#include <stdio.h>
const int MAX = 100;
const int SIZE = 10;
void fnBreadthFirstSearchReach(int vertex, int g[MAX][MAX], int v[MAX], int n);
typedef struct
{
int iaItems[10];
int iFront;
int iRear;
}QUEUE;
void fnQInsert(QUEUE *stQueue, int elem);
int fnQDelete(QUEUE *stQueue);
int fnQFull(QUEUE *stQueue);
int fnQEmpty(QUEUE *stQueue);
int main(void)
{
int graph[MAX][MAX];
int visited[MAX];
int numVert, startVert, i,j;
printf("Enter the number of vertices : ");
scanf("%d", &numVert);
printf("Enter the adjacency matrix :\n");
for (i=0; i<numVert; i++)
visited[i] = 0;
for (i=0; i<numVert; i++)
for (j=0; j<numVert; j++)
scanf("%d", &graph[i][j]);
printf("Enter the starting vertex : ");
scanf("%d", &startVert);
fnBreadthFirstSearchReach(startVert-1,graph,visited,numVert);
printf("Vertices which can be reached from vertex %d are :-\n",startVert);
for (i=0; i<numVert; i++)
if (visited[i])
printf("%d ",i+1);

printf("\n");
return 0;
}
void fnBreadthFirstSearchReach(int vertex, int g[MAX][MAX], int v[MAX], int n)
{
QUEUE stQueue;
stQueue.iFront = 0;
stQueue.iRear = -1;
int frontVertex, i;
v[vertex] = 1;
fnQInsert(&stQueue, vertex);
while (!fnQEmpty(&stQueue))
{
frontVertex = fnQDelete(&stQueue);
for (i=0; i<n; i++)
{
if (g[frontVertex][i] && !v[i])
{
v[i] = 1;
fnQInsert(&stQueue, i);
}
}
}
}
void fnQInsert(QUEUE *stQueue, int iItem)
{
if(fnQFull(stQueue))
printf("\nQueue Overflow\n");
else
{
stQueue->iRear++;
stQueue->iaItems[stQueue->iRear] = iItem;
}
}
int fnQDelete(QUEUE *stQueue)
{
int item;
if(fnQEmpty(stQueue))
printf("\nQueue Underflow\n");
else

if(stQueue->iRear == stQueue->iFront)
{
item = stQueue->iaItems[stQueue->iFront];
stQueue->iRear=-1;
stQueue->iFront=0;
}
else
{
item = stQueue->iaItems[stQueue->iFront++];
}
return item;
}
int fnQFull(QUEUE *stQueue)
{
if(stQueue->iRear == SIZE-1)
return 1;
else
return 0;
}
int fnQEmpty(QUEUE *stQueue)
{
if(stQueue->iRear == stQueue->iFront-1)
return 1;
else
return 0;
}
output:
Enter the number of vertices : 5
Enter the adjacency matrix :
0 1 1 0 0
1 0 0 1 1
1 0 0 0 0
0 1 0 0 0
0 1 0 0 0
Enter the starting vertex : 1
Vertices which can be reached from vertex 1 are :-
1 2 3 4 5
------------------------------------------------------------------------------
b)
#include <stdio.h>
const int MAX = 100;
void fnDepthFirstSearch(int currentVertex, int v[MAX], int g[MAX][MAX], int n);
int main(void)
{
int i,j,k;
int visited[MAX];
int graph[MAX][MAX];
int numVert, Vert;
printf("Enter the number of vertices : ");

scanf("%d", &numVert);
for (i=0; i<numVert; i++)
visited[i] = 0;
printf("Enter the adjacency matrix :\n");
for (i=0; i<numVert; i++)
for (j=0; j<numVert; j++)
scanf("%d", &graph[i][j]);
printf("Enter the source vertex : ");
scanf("%d", &Vert);
fnDepthFirstSearch(Vert,visited,graph,numVert);
for (k=0; k<numVert; k++)
{
if(visited[k])
{
printf("\nVertex %d is reachable\n", k+1);
}
else
{
printf("\nVertex %d is not reachable\n", k+1);
}
}
return 0;
}
void fnDepthFirstSearch(int currentVertex, int v[MAX], int g[MAX][MAX], int n)
{
int i;
v[currentVertex] = 1;
for (i=0; i<n; i++)
{
if (g[currentVertex][i] && !v[i])
fnDepthFirstSearch(i,v,g,n);
}
}
output:
Enter the number of vertices : 2
Enter the adjacency matrix :
0 1 1 0 0
1 0 0 1 1
1 0 0 0 0
0 1 0 0 0
0 1 0 0 00 1 1 0 0

1 0 0 1 1

1 0 0 0 0

0 1 0 0 0

0 1 0 0 0
Enter the source vertex : 
Vertex 1 is reachable

Vertex 2 is reachable
----------------------------------------------------------------------
12)
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_NUM_EMPLOYEES 100 // Maximum number of employees
#define MAX_HASH_TABLE_SIZE 50 // Maximum size of the hash table
// Define the structure for an employee record
typedef struct 
{
 int iKey; // 4-digit key
 char cName[50]; 
}EMPLOYEE;
// Define the hash table as an array of employee pointers
EMPLOYEE* stHashTable[MAX_HASH_TABLE_SIZE];
int fnCompHash(int, int);
void fnInsRecord(EMPLOYEE*, int);
EMPLOYEE* fnSrchRecord(int, int);
int main()
{
 int m; // Size of the hash table
 printf("Enter the size of the hash table (m): ");
 scanf("%d", &m);
 // Initialize the hash table with NULL pointers
 for (int i = 0; i < m; i++)
{
 stHashTable[i] = NULL;
 }
 FILE* file = fopen("employee.txt", "r");
 if(file == NULL)
{
 printf("Error opening file.\n");
 return 1;
 }

 int n = 0; 
 EMPLOYEE emp;
 while(fscanf(file, "%d %s", &emp.iKey, emp.cName) != EOF)
{
 EMPLOYEE* newEmp = (EMPLOYEE*)malloc(sizeof(EMPLOYEE));
 newEmp->iKey = emp.iKey;
 strcpy(newEmp->cName, emp.cName);
 fnInsRecord(newEmp, m);
 n++;
 }
 fclose(file);
 int iSrchKey;
 printf("Enter a key to search for an employee record: ");
 scanf("%d", &iSrchKey);
 EMPLOYEE* found = fnSrchRecord(iSrchKey, m);
 if(found != NULL)
{
 printf("Employee found with key %d:\n", found->iKey);
 printf("Name: %s\n", found->cName);
 }
 else
{
 printf("Employee with key %d not found.\n", iSrchKey);
 }
 return 0;
}
void fnInsRecord(EMPLOYEE* emp, int m)
{
 int index = fnCompHash(emp->iKey, m);
 // Linear probing if collisions happen
 while(stHashTable[index] != NULL)
{
 index = (index + 1) % m;
 }
 stHashTable[index] = emp;
}
int fnCompHash(int iKey, int m)

{
 return iKey % m;
}
EMPLOYEE* fnSrchRecord(int iKey, int m)
{
 int index = fnCompHash(iKey, m);
 // Linear probing
 while(stHashTable[index] != NULL)
{
 if(stHashTable[index]->iKey == iKey)
{
 return stHashTable[index];
 }
 index = (index + 1) % m;
 }
 return NULL; // Employee record not found
}

output:
Enter the size of the hash table (m): 50
Enter a key to search for an employee record: 5678
Employee found with key 5678:
Name: Alice
