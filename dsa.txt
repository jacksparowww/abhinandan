1)
#include<stdio.h>
#include <stdlib.h>
#include <string.h>

struct CalendarDay {
 char* dayName;
 int date;
 char* activity;
};

void create(struct CalendarDay calendar[7]) {
 for (int i = 0; i < 7; i++) {
 calendar[i].dayName = (char*)malloc(20); // Allocate memory for day name
 calendar[i].activity = (char*)malloc(100); // Allocate memory for activity description
 }
}

void read(struct CalendarDay calendar[7]) {
 for (int i = 0; i < 7; i++) {
 printf("Enter day name for Day %d: ", i + 1);
 scanf("%s", calendar[i].dayName);
 printf("Enter date for Day %d: ", i + 1);
 scanf("%d", &calendar[i].date);
 printf("Enter activity for Day %d: ", i + 1);
 scanf(" %[^\n]", calendar[i].activity); 


 }
}

void display(struct CalendarDay calendar[7]) {
 printf("\nActivity Details for the Week:\n");
 for (int i = 0; i < 7; i++) {
 printf("Day Name: %s\n", calendar[i].dayName);
 printf("Date: %d\n", calendar[i].date);
 printf("Activity: %s\n\n", calendar[i].activity);
 }
}
int main() {
 struct CalendarDay calendar[7];
 create(calendar);
 read(calendar);
 display(calendar);
 
 for (int i = 0; i < 7; i++) {
 free(calendar[i].dayName);
 free(calendar[i].activity);
 }
 return 0;
}
------------------------------------------------------------------------
2)#include<stdio.h>
#include<stdlib.h>
#include<string.h>

char str[100], pat[50], rep[50], ans[100];
int i, j, c, m, k, flag = 0;

void stringmatch() {
    i = m = c = j = 0;
    while (str[c] != '\0') {
        if (str[m] == pat[i]) {
            i++, m++;
            if (pat[i] == '\0') {
                flag = 1;
                for (k = 0; rep[k] != '\0'; k++, j++)
                    ans[j] = rep[k];
                i = 0;
                c = m;
            }
        }
        else {
            ans[j] = str[c];
            j++;
            c++;
            m = c;
            i = 0;
        }
    }
    ans[j] = '\0'; // Null terminate the resultant string
}

int main() {
    printf("\nEnter main string: ");
    gets(str); // Note: gets() is deprecated, consider using fgets() instead
    printf("\nEnter pattern string: ");
    gets(pat);
    printf("Enter replace string: ");
    gets(rep);
    stringmatch();
    if (flag == 1)
        printf("\nThe resultant string: %s", ans);
    else
        printf("\nPattern not found.");
    return 0;
}
-----------------------------------------------------------------------------------
3)
#include <stdio.h>

#define MAX_SIZE 5

int top = -1;
int stack[MAX_SIZE];

void push(int item) {
    if (top == MAX_SIZE - 1) {
        printf("Overflow\n");
    } else {
        stack[++top] = item;
    }
}

int pop() {
    int num;
    if (top == -1) {
        printf("Underflow\n");
        return -1; // return an error value
    } else {
        num = stack[top--];
        return num;
    }
}

int isPalindrome() {
    if (top == -1) {
        printf("Stack is empty\n");
        return -1; // return an error value
    }
    int i;
    for (i = 0; i <= top / 2; i++) {
        if (stack[i] != stack[top - i]) {
            return 0; // Not palindrome
        }
    }
    return 1; // Palindrome
}

void display() {
    if (top == -1) {
        printf("Stack is empty\n");
    } else {
        printf("Stack content:\n");
        for (int i = top; i >= 0; i--) {
            printf("%d\n", stack[i]);
        }
    }
}

int main() {
    int choice, item;

    do {
        printf("\nMain Menu\n");
        printf("1. Push\n");
        printf("2. Pop\n");
        printf("3. Check Palindrome\n");
        printf("4. Display\n");
        printf("5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter an element to push: ");
                scanf("%d", &item);
                push(item);
                break;
            case 2:
                item = pop();
                if (item != -1) {
                    printf("Popped item: %d\n", item);
                }
                break;
            case 3:
                if (isPalindrome() == 1) {
                    printf("Stack content is palindrome\n");
                } else if (isPalindrome() == 0) {
                    printf("Stack content is not palindrome\n");
                }
                break;
            case 4:
                display();
                break;
            case 5:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice\n");
        }
    } while (choice != 5);

    return 0;
}

-------------------------------------------------------------------------------------
4)#include<stdio.h>

void push(char);
char pop();
void eval();
int prec(char);

char infix[30], postfix[30], stack[30];
int top = -1;

int main() {
    printf("Enter a valid infix expression: ");
    scanf("%s", infix);
    eval();
    printf("Postfix expression is %s\n", postfix);
    return 0;
}

void eval() {
    int i = 0, j = 0;
    char symb, temp;
   

    for (i = 0; infix[i] != '\0'; i++) {
        symb = infix[i];
        switch (symb) {
            case '(':
                push(symb);
                break;
            case ')':
                temp = pop();
                while (temp != '(') {
                    postfix[j] = temp;
                    j++;
                    temp = pop();
                }
                break;
            case '+':
            case '-':
            case '*':
            case '/':
            case '%':
            case '^':
                while (prec(stack[top]) >= prec(symb)) {
                    temp = pop();
                    postfix[j] = temp;
                    j++;
                }
                push(symb);
                break;
            default:
                postfix[j] = symb;
                j++;
        }
    }

    while (top > -1) {
        temp = pop();
        postfix[j] = temp;
        j++;
    }
    postfix[j] = '\0';
}

void push(char item) {
    top++;
    stack[top] = item;
}

char pop() {
    char item;
    if (top == -1) {
        printf("Stack Underflow\n");
        return -1;
    } else {
        item = stack[top];
        top--;
        return item;
    }
}

int prec(char symbol) {
    switch (symbol) {
        case '^':
            return 3;
        case '*':
        case '/':
        case '%':
            return 2;
        case '+':
        case '-':
            return 1;
        default:
            return 0;
    }
}
------------------------------------------------------------------------------------
5 a)
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

void push(int[], int *, int);
int pop(int[], int *);

int main() {
    int iastack[50], i, op1, op2, res;
    char expr[50], symb;
    int top = -1;

    printf("\nEnter a valid postfix expression: ");
    scanf("%s", expr);

    for (i = 0; i < strlen(expr); i++) {
        symb = expr[i];
        if (isdigit(symb)) {
            push(iastack, &top, symb - '0');
        } else {
            op2 = pop(iastack, &top);
            op1 = pop(iastack, &top);
            switch (symb) {
                case '+':
                    res = op1 + op2;
                    break;
                case '-':
                    res = op1 - op2;
                    break;
                case '*':
                    res = op1 * op2;
                    break;
                case '/':
                    if (op2 != 0)
                        res = op1 / op2;
                    else {
                        printf("Error: Division by zero\n");
                        exit(1);
                    }
                    break;
                case '%':
                    if (op2 != 0)
                        res = op1 % op2;
                    else {
                        printf("Error: Modulo by zero\n");
                        exit(1);
                    }
                    break;
                case '^':
                    res = (int)pow(op1, op2);
                    break;
            }
            push(iastack, &top, res);
        }
    }
    res = pop(iastack, &top);
    printf("\nValue of %s expression is %d\n", expr, res);
    return 0;
}

void push(int Stack[], int *t, int elem) {
    *t = *t + 1;
    Stack[*t] = elem;
}

int pop(int Stack[], int *t) {
    int elem;
    elem = Stack[*t];
    *t = *t - 1;
    return elem;
}
-----------------------------------------------------------------------------------
5 b)#include <stdio.h>

void towers(int, char, char, char);

int main() {
    int num;
    printf("Enter the number of disks: ");
    scanf("%d", &num);
    printf("The sequence of moves involved in the Tower of Hanoi are:\n");
    towers(num, 'A', 'C', 'B');
    printf("\n");
    return 0;
}

void towers(int num, char frompeg, char topeg, char auxpeg) {
    if (num == 1) {
        printf("\nMove disk 1 from peg %c to peg %c", frompeg, topeg);
        return;
    }
    towers(num - 1, frompeg, auxpeg, topeg);
    printf("\nMove disk %d from peg %c to peg %c", num, frompeg, topeg);
    towers(num - 1, auxpeg, topeg, frompeg);
}
-------------------------------------------------------------------------------------
6.#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define SIZE 5

void insert(char [], int *, int *, char);
char del(char [], int *, int *);
void display(char [], int, int);
bool qfull(int, int);
bool qempty(int, int);

int main() {
    char q[SIZE];
    int front = -1, rear = -1;
    int choice;
    char elem;

    for (;;) {
        printf("\nQueue Operations\n");
        printf("=====================");
        printf("\n1. Qinsert\n2. Qdelete\n3. Qdisplay\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        getchar(); // Consume newline character

        switch (choice) {
            case 1:
                if (!qfull(front, rear)) {
                    printf("\nEnter an element: ");
                    scanf("%c", &elem);
                    insert(q, &front, &rear, elem);
                } else {
                    printf("\nQueue is Full\n");
                }
                break;

            case 2:
                if (!qempty(front, rear)) {
                    elem = del(q, &front, &rear);
                    printf("\nDeleted element is %c\n", elem);
                } else {
                    printf("\nQueue is Empty\n");
                }
                break;

            case 3:
                if (!qempty(front, rear)) {
                    printf("\nContents of the Queue are:\n");
                    display(q, front, rear);
                } else {
                    printf("\nQueue is Empty\n");
                }
                break;

            case 4:
                exit(0);

            default:
                printf("\nInvalid choice\n");
                break;
        }
    }

    return 0;
}

bool qfull(int front, int rear) {
    if ((rear + 1) % SIZE == front)
        return true;
    else
        return false;
}

bool qempty(int front, int rear) {
    if (front == -1)
        return true;
    else
        return false;
}

void insert(char queue[], int *front, int *rear, char val) {
    if (*rear == -1) {
        *front = *rear = 0;
    } else {
        *rear = (*rear + 1) % SIZE;
    }
    queue[*rear] = val;
}

char del(char queue[], int *front, int *rear) {
    char el = queue[*front];
    if (*front == *rear) {
        *front = *rear = -1;
    } else {
        *front = (*front + 1) % SIZE;
    }
    return el;
}

void display(char queue[], int front, int rear) {
    int i;
    if (front <= rear) {
        for (i = front; i <= rear; i++) {
            printf("%c\t", queue[i]);
        }
    } else {
        printf("\n");
        for (i = front; i < SIZE; i++) {
            printf("%c\t", queue[i]);
        }
        for (i = 0; i <= rear; i++) {
            printf("%c\t", queue[i]);
        }
        printf("\n");
    }
}
-------------------------------------------------------------------------------------------------
7.#include<stdio.h>
#include<stdlib.h>
#include<string.h>

struct node {
    char usn[11], name[40], prog[4];
    int sem;
    char ph[11];
    struct node *link;
};

typedef struct node* PTR;

PTR get(void);
void freeN(PTR);
PTR insrear(PTR);
PTR delfront(PTR);
PTR insfront(PTR);
PTR delrear(PTR);
void disp(PTR);

int main() {
    PTR first = NULL;
    int ch, num, i;
    
    printf("\nEnter the number of Students N: ");
    scanf("%d", &num);

    for (i = 0; i < num; i++) {
        printf("Enter Data for Node %d: ", i + 1);
        first = insfront(first);
    }

    for (;;) {
        printf("\nQUEUE OPERATIONS");
        printf("====================");
        printf("\n1. Insert Front\n2. Insert Rear\n3. Delete Front\n4. Delete Rear\n5. Display\n6. Exit\n");
        printf("\nEnter your choice: ");
        scanf("%d", &ch);
        switch (ch) {
            case 1:
                first = insfront(first);
                break;
            case 2:
                first = insrear(first);
                break;
            case 3:
                first = delfront(first);
                break;
            case 4:
                first = delrear(first);
                break;
            case 5:
                disp(first);
                break;
            case 6:
                exit(0);
        }
    }
    return 0;
}

PTR get() {
    PTR newborn;
    newborn = (PTR)malloc(sizeof(struct node));
    if (newborn == NULL) {
        printf("\nMemory Overflow");
        exit(0);
    }
    printf("\nEnter USN: ");
    scanf("%s", newborn->usn);
    printf("Enter name: ");
    scanf("%s", newborn->name);
    printf("Enter Program name: ");
    scanf("%s", newborn->prog);
    printf("Enter semester: ");
    scanf("%d", &newborn->sem);
    printf("Enter Phone no: ");
    scanf("%s", newborn->ph);
    return newborn;
}

void freeN(PTR x) {
    free(x);
}

PTR insrear(PTR first) {
    PTR temp, cur;
    temp = get();
    temp->link = NULL;
    if (first == NULL)
        return temp;
    cur = first;
    while (cur->link != NULL) {
        cur = cur->link;
    }
    cur->link = temp;
    return first;
}

PTR delfront(PTR first) {
    PTR temp;
    if (first == NULL) {
        printf("\nSLL is empty cannot delete");
        return first;
    }
    temp = first;
    first = first->link;
    printf("\nNode deleted is %s : ", temp->name);
    freeN(temp);
    return first;
}

void disp(PTR first) {
    PTR curr;
    int count = 0;
    if (first == NULL) {
        printf("\nSLL is empty ");
        return;
    }
    printf("\nThe contents of SLL are : ");
    curr = first;
    printf("\nUSN\t\tName\tProgram\tSem\tPhone num");
    while (curr != NULL) {
        printf("\n%10s\t%s\t%s\t%d\t%s", curr->usn, curr->name, curr->prog, curr->sem, curr->ph);
        curr = curr->link;
        count++;
    }
    printf("\n\nSLL has %d nodes", count);
}

PTR insfront(PTR first) {
    PTR temp;
    temp = get();
    temp->link = first;
    return temp;
}

PTR delrear(PTR first) {
    PTR cur, prev;
    if (first == NULL) {
        printf("\nSLL is empty cannot delete");
        return first;
    }
    prev = NULL;
    cur = first;
    if (cur->link == NULL) {
        printf("\nNode deleted for %s : ", cur->name);
        freeN(cur);
        return NULL;
    }
    while (cur->link != NULL) {
        prev = cur;
        cur = cur->link;
    }
    prev->link = cur->link;
    printf("\nNode deleted for %s : ", cur->name);
    freeN(cur);
    return first;
}
---------------------------------------------------------------------------------------------------
9)
show array representation of two polynomial write a c function to add two polynomial A(x) and B(x) A(x)=2x^10+x+3, B(x)=x^5+10x^3+3x^2+12

#include<stdio.h>

#define size 11

void add(int pA[],int pB[],int pC[]){
    for (int i = 0; i < size; i++)
    {
        pC[i]=pA[i]+pB[i];
        /* code */
    }
    
}

void pri(int p[]){
    for (int i=size-1; i>=0; i--)
    {
        //printf("polynomial");
        if (p[i]!=0)
        {
            if (i!=0)
            {
                printf("%dx^%d+",p[i],i);
                /* code */
            }
            else{
                printf("%d",p[i]);
            }
            
            /* code */
        }
        
        /* code */
    }
    printf("\n");
}
int main(){
    int pA[size]={3,1,0,0,0,0,0,0,0,0,2};
    int  pB[size]={12,0,3,10,0,1};
    int pC[size]={0};
    add(pA,pB,pC);
    pri(pA);
    printf("\n");
    pri(pB);
    pri(pC);
    return 0;
}
--------------------------------------------------------------------------------------------------------
8)

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
struct node
{
int usn;
char name[30], dept[4], desig[30], ph[11];
 int sal;
struct node *plink;
struct node *nlink;
};
typedef struct node* NODE;
NODE getn(void);
void freen(NODE);
NODE insrear(NODE);
NODE delfront(NODE);
NODE insfront(NODE);
NODE delrear(NODE);
void disp(NODE);
int main()
{
NODE first = NULL;
int ch, num, i;
 printf("\nEnter the number of Employees N : "); scanf("%d", &num);
for(i=0;i<num;i++)
{
printf("\nEnter Data for Node %d :\n", i+1);
first = insrear(first);
}
for(;;)
{
printf("\nDLL OPERATIONS\n");
printf("====================");

printf("\n1.Insert Rear\n2.Delete Front\n3.Insert Front\n4.Delete Rear\n5.Display\n6.Exit\n");
printf("\nEnter your choice\n");
scanf("%d",&ch);
switch(ch)
{
case 1: first = insrear(first);
break;
case 2: first = delfront(first);
break;
case 3: first = insfront(first);
break;
case 4: first = delrear(first);
break;
case 5: disp(first);
break;
case 6: exit(0);
}
}
 return 0;
}
NODE getn()
{
NODE newborn;
newborn = (NODE)malloc(sizeof(struct node));
if(newborn == NULL)
{
printf("\nMemory Overflow");
exit(0);
}
printf("\nEnter SSN : ");
 scanf("%d",&newborn->usn);
 printf("\nEnter name : ");
scanf("%s",newborn->name);
 printf("\nEnter Department : ");
 scanf("%s", newborn->dept);
 printf("\nEnter Designation : ");
 scanf("%s", newborn->desig);
printf("\nEnter Salary : ");
 scanf("%d",&newborn->sal);
printf("\nEnter Phone no : ");
 scanf("%s",newborn->ph);
return newborn;
}

void freen(NODE x)
{
free(x);
}
NODE insrear(NODE first)
{
NODE temp,cur;
temp = getn();
temp->plink = temp->nlink = NULL;
 if(first == NULL)
 return temp;
 cur = first;
 while(cur->nlink != NULL)
 {
 cur = cur->nlink;
 }
 cur->nlink = temp;
 temp->plink = cur;
 return first;
}
NODE insfront(NODE first)
{
 NODE temp;
temp = getn();
 temp->plink = temp->nlink = NULL;
 temp->nlink = first;
 first = temp;
 return first;
}
NODE delrear(NODE first)
{
NODE cur, prev;
if(first == NULL)
{
printf("\nDLL is empty\n");
return first;
}

cur = first;
if(cur->nlink == NULL)
{
 printf("\nNode deleted for %s\n",cur->name);
 freen(cur);
 return NULL;
}
 while(cur->nlink != NULL)
 {
 cur = cur->nlink;
 }
 prev = cur->plink;
 prev->nlink = NULL;
printf("\nNode deleted for %s\n",cur->name);
freen(cur);
return first;
}
NODE delfront(NODE first)
{
NODE temp;
if(first == NULL)
{
printf("\nDLL is empty\n");
return first;
}
if(first->nlink == NULL)
{
printf("\nNode deleted for %s\n",first->name);
freen(first);
return NULL;
}
temp = first;
first = first->nlink;
first->plink = NULL;
printf("\nNode deleted for %s\n",temp->name);
freen(temp);
return first;
}

void disp(NODE first)
{
NODE curr;
int count = 0;
if(first == NULL)
{
printf("\nDLL is empty\n");
return;
}
printf("\nThe contents of DLL are :\n");
curr = first;
 printf("\nSSN\tName\tDept\tDesignation\tSalary\t\tPhone No");
while(curr != NULL)
{
printf("\n%-5d\t%s\t%s\t%s\t\t%-7d\t\t%-11s",curr->usn, curr->name, curr->dept, curr->desig, 
curr->sal, curr->ph);
curr = curr->nlink;
count++;
}
printf("\n\nDLL has %d nodes\n", count);
}
----------------------------------------------------------------------------------------
10)
#include <stdio.h>
#include <stdlib.h>

// Structure of a BST node
struct Node {
    int data;
    struct Node *left;
    struct Node *right;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a node into BST
struct Node* insert(struct Node* root, int data) {
    if (root == NULL)
        return createNode(data);
    
    if (data < root->data)
        root->left = insert(root->left, data);
    else if (data > root->data)
        root->right = insert(root->right, data);
    
    return root;
}

// Function to traverse the BST in inorder
void inorderTraversal(struct Node* root) {
    if (root != NULL) {
        inorderTraversal(root->left);
        printf("%d ", root->data);
        inorderTraversal(root->right);
    }
}

// Function to traverse the BST in preorder
void preorderTraversal(struct Node* root) {
    if (root != NULL) {
        printf("%d ", root->data);
        preorderTraversal(root->left);
        preorderTraversal(root->right);
    }
}

// Function to traverse the BST in postorder
void postorderTraversal(struct Node* root) {
    if (root != NULL) {
        postorderTraversal(root->left);
        postorderTraversal(root->right);
        printf("%d ", root->data);
    }
}

// Function to search for a key in the BST
void search(struct Node* root, int key) {
    if (root == NULL) {
        printf("Element %d not found in BST.\n", key);
        return;
    }

    if (root->data == key) {
        printf("Element %d found in BST.\n", key);
        return;
    }

    if (key < root->data)
        search(root->left, key);
    else
        search(root->right, key);
}

int main() {
    struct Node* root = NULL;
    int choice, key;

    // Creating the initial BST
    int arr[] = {6, 9, 5, 2, 8, 15, 24, 14, 7, 8, 5, 2};
    int n = sizeof(arr) / sizeof(arr[0]);
    for (int i = 0; i < n; i++)
        root = insert(root, arr[i]);

    do {
        printf("\n----- MENU -----\n");
        printf("1. Traverse BST (Inorder)\n");
        printf("2. Traverse BST (Preorder)\n");
        printf("3. Traverse BST (Postorder)\n");
        printf("4. Search Element in BST\n");
        printf("5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Inorder Traversal: ");
                inorderTraversal(root);
                printf("\n");
                break;
            case 2:
                printf("Preorder Traversal: ");
                preorderTraversal(root);
                printf("\n");
                break;
            case 3:
                printf("Postorder Traversal: ");
                postorderTraversal(root);
                printf("\n");
                break;
            case 4:
                printf("Enter element to search: ");
                scanf("%d", &key);
                search(root, key);
                break;
            case 5:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice! Please enter a valid choice.\n");
        }
    } while (choice != 5);

    return 0;
}
---------------------------------------------------------------------
11)
#include <stdio.h>

int a[20][20], q[20], vis[20];
int n, i, j, f = 0, r = -1;

void create() {
    printf("Enter number of cities: ");
    scanf("%d", &n);
    printf("Enter adjacency matrix:\n");
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= n; j++) {
            scanf("%d", &a[i][j]);
        }
    }
}

void bfs(int v) {
    for (i = 1; i <= n; i++) {
        if (a[v][i] && !vis[i]) {
            q[++r] = i;
            vis[i] = 1;
        }
    }
}

int main() {
    int v, c;
    while (1) {
        printf("\n1. Create\n2. Print reachable nodes\nChoice: ");
        scanf("%d", &c);
        switch (c) {
            case 1:
                create();
                break;
            case 2:
                printf("Enter vertex: ");
                scanf("%d", &v);
                if (v < 1 || v > n) {
                    printf("Invalid vertex\n");
                } else {
                    for (i = 1; i <= n; i++) {
                        vis[i] = 0;
                    }
                    vis[v] = 1;
                    bfs(v);
                    printf("The reachable nodes from vertex %d:\n", v);
                    for (i = 1; i <= n; i++) {
                        if (vis[i] && i != v) {
                            printf("Node %d\n", i);
                        }
                    }
                }
                break;
            default:
                printf("Invalid choice\n");
        }
    }
    return 0;
}
output:
1. Create
2. Print reachable nodes
Choice: 1
Enter number of cities: 3
Enter adjacency matrix:
0 1 1
1 0 1
1 1 0

1. Create
2. Print reachable nodes
Choice: 2
Enter vertex: 1
The reachable nodes from vertex 1:
Node 2
Node 3

1. Create
2. Print reachable nodes
Choice:

----------------------------------------------------------------------
12)
#include <stdio.h>
#define max 10

void linear(int a[max]) {
    int flag, k, i, add, c;
    char ans;
    do {
        flag = 0;
        c = 0;
        printf("Enter 4 digit key: ");
        scanf("%4d", &k);
        add = k % max;
        if (a[add] == -1) {
            a[add] = k;
        } else {
            printf("\nCollision detected...");
            i = 0;
            while (i < max) {
                if (a[i] != -1) {
                    c++;
                }
                i++;
            }
            if (c == max) {
                printf("\nHash table is full");
                disp(a);
                return;
            }
            printf("\nCollision avoided");
            for (i = add + 1; i < max; i++) {
                if (a[i] == -1) {
                    a[i] = k;
                    flag = 1;
                    break;
                }
            }
            i = 0;
            while ((i < add) && (flag == 0)) {
                if (a[i] == -1) {
                    a[i] = k;
                    flag = 1;
                    break;
                }
                i++;
            }
        }
    } while (1);
}

void disp(int a[max]) {
    int i;
    printf("\nHash table \tAddress\tKey\n");
    for (i = 0; i < max; i++) {
        printf("%d \t\t %d \t %d\n", i, &a[i], a[i]);
    }
}

int main() {
    int a[max], i, c;
    for (i = 0; i < max; i++)
        a[i] = -1;
    while (1) {
        printf("\n1. Insert into hash table\n2. Display hash table\nEnter your choice: ");
        scanf("%d", &c);
        switch (c) {
            case 1:
                linear(a);
                break;
            case 2:
                disp(a);
                break;
            default:
                printf("Invalid choice\n");
                break;
        }
    }
    return 0;
}
output:
1. Insert into hash table
2. Display hash table
Enter your choice: 1
Enter 4 digit key: 5643
Enter 4 digit key: 4345
Enter 4 digit key: 6423

Collision detected...
Collision avoidedEnter 4 digit key: 1234

Collision detected...
Collision avoidedEnter 4 digit key: 
